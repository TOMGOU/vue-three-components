{"version":3,"file":"Grass.stories-32a147a7.js","sources":["../../packages/Grass/shader/vertex.ts","../../packages/Grass/shader/fragment.ts","../../packages/Grass/index.ts","../../src/stories/components/grass/index.vue"],"sourcesContent":["const vertexShader = /*glsl*/ `\n\n  precision lowp float;\n  attribute vec3 position;\n  attribute vec2 uv;\n  uniform mat4 modelMatrix;\n  uniform mat4 viewMatrix;\n  uniform mat4 projectionMatrix;\n  varying vec2 vUv;\n\n  void main(){\n    vUv = uv;\n    vec4 modelPosition = modelMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\n  }\n`\n\nexport default vertexShader\n","const fragmentShaderGrass = /*glsl*/ `\n\n  precision highp float;\n\n  varying vec2 vUv;\n\n  #define BLADES_SPACING 0.004\n  #define JITTER_MAX 0.004\n  // depends on size of grass blades in pixels\n  #define LOOKUP_DIST 5\n\n  #define HASHSCALE1 .1031\n  #define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n  #define PI 3.14\n\n  float hash12(vec2 p)\n  {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n  }\n\n  ///  3 out, 2 in...\n  vec3 hash32(vec2 p)\n  {\n    vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n      p3 += dot(p3, p3.yxz+19.19);\n      return fract((p3.xxy+p3.yzz)*p3.zyx);\n  }\n\n  /// 2 out, 2 in...\n  vec2 hash22(vec2 p)\n  {\n    vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n      p3 += dot(p3, p3.yzx+19.19);\n      return fract((p3.xx+p3.yz)*p3.zy);\n\n  }\n\n  vec3 getGrassColor(float x) {\n      vec3 a = vec3(0.2, 0.4, 0.3);\n      vec3 b = vec3(0.3, 0.5, 0.2);\n      vec3 c = vec3(0.2, 0.4, 0.2);\n      vec3 d = vec3(0.66, 0.77, 0.33);\n      vec3 col = a + b * cos(2. * PI * (c * x + d));\n      return col;\n  }\n\n  float getGrassBlade(in vec2 position, in vec2 grassPos, out vec4 color) {\n    // between {-1, -1, -1} and {1, 1, 1}\n      vec3 grassVector3 = hash32(grassPos * 123512.41) * 2.0 - vec3(1);\n      // keep grass z between 0 and 0.4\n      grassVector3.z = grassVector3.z * 0.2 + 0.2;\n      vec2 grassVector2 = normalize(grassVector3.xy);\n\n      float grassLength = hash12(grassPos * 102348.7) * 0.01 + 0.012;\n\n      // take coordinates in grass blade frame\n      vec2 gv = position - grassPos;\n      float gx = dot(grassVector2, gv);\n      float gy = dot(vec2(-grassVector2.y, grassVector2.x), gv);\n      float gxn = gx / grassLength;\n\n      // TODO make gy depends to gx\n      if (gxn >= 0.0 && gxn <= 1.0 && abs(gy) <= 0.0008 * (1. - gxn * gxn)) {\n          vec3 thisGrassColor = getGrassColor(hash12(grassPos * 2631.6));\n          color = vec4(thisGrassColor * (.2 + 0.8 * gxn), 1.0);\n        return grassVector3.z * gxn;\n      }\n      else {\n          color = vec4(0., 0., 0., 1.);\n          return -1.0;\n      }\n  }\n\n  float getPoint(in vec2 position, out vec4 color) {\n      int xcount = int(1. / BLADES_SPACING);\n      int ycount = int(1. / BLADES_SPACING);\n      int ox = int(position.x * float(xcount));\n      int oy = int(position.y * float(ycount));\n\n      float maxz = 0.0;\n\n      for (int i = -LOOKUP_DIST; i < LOOKUP_DIST; ++i) {\n          for (int j = -LOOKUP_DIST; j < LOOKUP_DIST; ++j) {\n              vec2 upos = vec2(ox + i, oy + j);\n              vec2 grassPos = (upos * BLADES_SPACING + hash22(upos) * JITTER_MAX);\n\n              vec4 tempColor;\n              float z = getGrassBlade(position, grassPos, tempColor);\n\n              if (z > maxz) {\n                  maxz = z;\n                  color = tempColor;\n              }\n          }\n      }\n      if (maxz == 0.0) {\n          color = vec4(0.);\n      }\n\n      return maxz;\n  }\n\n  void main() {\n      vec4 color;\n      float z = getPoint(vUv, color);\n      gl_FragColor = color;\n  }\n`\n\nexport default fragmentShaderGrass\n","import * as THREE from 'three'\nimport vertexShader from './shader/vertex'\nimport fragmentShader from './shader/fragment'\n\nconst createGrass = (width = 8.5, height = 4.2) => {\n  const rawShaderMaterial = new THREE.RawShaderMaterial({\n    // color: 0x00ff00,\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    side: THREE.DoubleSide,\n  })\n\n  const ripper: THREE.Mesh = new THREE.Mesh(new THREE.PlaneGeometry(width, height, 64, 64), rawShaderMaterial)\n\n  return ripper\n}\n\nexport { createGrass }\n","<template>\n  <div id=\"Grass\"></div>\n</template>\n\n<script setup lang=\"ts\">\nimport { onMounted, onBeforeUpdate, ref, onBeforeMount } from 'vue';\nimport * as THREE from 'three'\n// import { controls } from '../basic/controls'\nimport { scene, renderer, camera } from '../basic/three'\nimport { createGrass } from '../../../../packages/index'\n\n// const props = defineProps({\n//   size: {\n//     type: Number,\n//     default: 20,\n//     required: false\n//   },\n//   color: {\n//     type: String,\n//     default: '#15de1d',\n//     required: false\n//   }\n// })\n\nlet timer: any = null\n\nonBeforeMount(() => {\n  if (timer) cancelAnimationFrame(timer)\n  scene.remove.apply(scene, scene.children)\n})\n\nonMounted(() => {\n  camera.zoom = 1;\n  const Grass = createGrass(2000, 1600)\n  scene.add( Grass );\n\n  const axesHelper = new THREE.AxesHelper(5000);\n  // scene.add(axesHelper);\n\n  const WaveElement = document.getElementById('Grass')\n  if (WaveElement) WaveElement.appendChild(renderer.domElement)\n  const render = () => {\n    renderer.render(scene, camera)\n    camera.updateProjectionMatrix()\n    // controls.update()\n    timer = requestAnimationFrame(render)\n  }\n\n  render()\n})\n\nonBeforeUpdate(() => {\n  console.log('onBeforeUpdate')\n  renderer.clear()\n  scene.remove.apply(scene, scene.children)\n  scene.remove.apply(scene, scene.children)\n  renderer.forceContextLoss()\n  cancelAnimationFrame(timer)\n  const gl = renderer.domElement.getContext('webgl')\n  gl && gl.getExtension('WEBGL_lose_context')?.loseContext()\n})\n</script>"],"names":["vertexShader","fragmentShaderGrass","createGrass","__name","width","height","rawShaderMaterial","THREE.RawShaderMaterial","fragmentShader","THREE.DoubleSide","THREE.Mesh","THREE.PlaneGeometry","timer","onBeforeMount","scene","onMounted","camera","Grass","THREE.AxesHelper","WaveElement","renderer","render","onBeforeUpdate","gl","_a"],"mappings":"mPAAA,MAAMA,EAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAxBC,EAA+B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECI/BC,EAAcC,EAAA,CAACC,EAAQ,IAAKC,EAAS,MAAQ,CAC3C,MAAAC,EAAoB,IAAIC,EAAwB,CAEpD,aAAAP,EAAA,eACAQ,EACA,KAAMC,CAAM,CACb,EAIM,OAFoB,IAAIC,EAAW,IAAIC,EAAoBP,EAAOC,EAAQ,GAAI,EAAE,EAAGC,CAAiB,CAG7G,EAXoB,2DCoBpB,IAAIM,EAAa,KAEjB,OAAAC,EAAc,IAAM,CACdD,GAAO,qBAAqBA,CAAK,EACrCE,EAAM,OAAO,MAAMA,EAAOA,EAAM,QAAQ,CAAA,CACzC,EAEDC,EAAU,IAAM,CACdC,EAAO,KAAO,EACR,MAAAC,EAAQf,EAAY,IAAM,IAAI,EACpCY,EAAM,IAAKG,CAAM,EAEE,IAAIC,EAAiB,GAAI,EAGtC,MAAAC,EAAc,SAAS,eAAe,OAAO,EAC/CA,GAAyBA,EAAA,YAAYC,EAAS,UAAU,EAC5D,MAAMC,EAASlB,EAAA,IAAM,CACViB,EAAA,OAAON,EAAOE,CAAM,EAC7BA,EAAO,uBAAuB,EAE9BJ,EAAQ,sBAAsBS,CAAM,CAAA,EAJvB,UAORA,GAAA,CACR,EAEDC,EAAe,IAAM,OACnB,QAAQ,IAAI,gBAAgB,EAC5BF,EAAS,MAAM,EACfN,EAAM,OAAO,MAAMA,EAAOA,EAAM,QAAQ,EACxCA,EAAM,OAAO,MAAMA,EAAOA,EAAM,QAAQ,EACxCM,EAAS,iBAAiB,EAC1B,qBAAqBR,CAAK,EAC1B,MAAMW,EAAKH,EAAS,WAAW,WAAW,OAAO,EACjDG,KAAMC,EAAAD,EAAG,aAAa,oBAAoB,IAApC,MAAAC,EAAuC,cAAY,CAC1D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}