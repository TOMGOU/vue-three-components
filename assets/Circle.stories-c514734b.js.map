{"version":3,"file":"Circle.stories-c514734b.js","sources":["../../packages/WaveCircle/shader/vertex.ts","../../packages/WaveCircle/shader/fragment.ts","../../packages/WaveCircle/index.ts","../../src/stories/components/circle/index.vue"],"sourcesContent":["const vertexShader = /*glsl*/ `\n  precision lowp float;\n  varying vec2 vUv;\n\n  void main(){\n    vec4 modelPosition = modelMatrix * vec4( position, 1.0 );\n    vUv=uv;\n    gl_Position =  projectionMatrix * viewMatrix * modelPosition;\n  }\n`\n\nexport default vertexShader\n","const fragmentShader = /*glsl*/ `\n  precision lowp float;\n  varying vec2 vUv;\n  uniform float uTime;\n\n\n  void main(){\n    float radius = length(vUv - 0.5);\n    float timestamp = fract(uTime * 0.5) * 0.8;\n    float innerRadius[3];\n    float outerRadius[3];\n    float deltaRadius = 0.15;\n    float innerStart = timestamp;\n    float outerStart = innerStart + 0.05;\n\n    // 使用 for 循环计算内圆半径和外圆半径\n    for (int i = 0; i < 3; i++) {\n      innerRadius[i] = innerStart + float(i) * deltaRadius;\n      outerRadius[i] = outerStart + float(i) * deltaRadius;\n    }\n\n    // 使用 smoothstep 函数来实现颜色渐变\n    vec4 color = vec4(0.0, 1.0, 0.5, 1);\n    float blend = smoothstep(innerRadius[0], outerRadius[0], radius);\n    blend = mix(blend, smoothstep(innerRadius[1], outerRadius[1], radius), step(outerRadius[0], radius));\n    blend = mix(blend, smoothstep(innerRadius[2], outerRadius[2], radius), step(outerRadius[1], radius));\n    blend = step(radius, outerRadius[2]) * blend;\n\n    // 设置颜色\n    gl_FragColor = mix(vec4(0.0, 0.1, 0.1, 0), color, blend);\n  }\n`\n\nexport default fragmentShader\n","import * as THREE from 'three'\nimport vertexShader from './shader/vertex'\nimport fragmentShader from './shader/fragment'\n\nconst createWaveCircle = (size: number = 20) => {\n  const geometry = new THREE.CircleGeometry(size * 10, 64) //默认在XOY平面上\n  const material = new THREE.ShaderMaterial({\n    vertexShader,\n    fragmentShader,\n    uniforms: {\n      // 动画时间\n      uTime: {\n        value: 0\n      }\n    },\n    side: THREE.DoubleSide,\n    transparent: true,\n    depthTest: true,\n    depthWrite: true,\n    // depthFunc: THREE.LessEqualDepth,\n    // alphaTest: 0.2\n    // blending: THREE.CustomBlending,\n    // blendSrc: THREE.SrcAlphaFactor,\n    // blendDst: THREE.OneMinusSrcAlphaFactor\n  })\n  const mesh = new THREE.Mesh(geometry, material) //网格模型对象Mesh\n  mesh.name = 'circle-wave'\n\n  const clock = new THREE.Clock()\n  function animate() {\n    const elapsedTime = clock.getElapsedTime()\n    material.uniforms.uTime.value = elapsedTime\n    requestAnimationFrame(animate)\n  }\n\n  animate()\n\n  return mesh\n}\n\nexport { createWaveCircle }\n","<template>\n  <div id=\"Circle\"></div>\n</template>\n\n<script setup lang=\"ts\">\nimport { onMounted, onBeforeUpdate, watch, onBeforeMount } from 'vue';\nimport * as THREE from 'three'\nimport { scene, renderer, camera } from '../basic/three'\n// import { controls } from '../basic/controls'\nimport { createWaveCircle } from '../../../../packages/index'\n\nconst props = defineProps({\n  size: {\n    type: Number,\n    default: 20,\n    required: false\n  }\n})\n\nlet timer: any = null\n\nonBeforeMount(() => {\n  if (timer) cancelAnimationFrame(timer)\n  scene.remove.apply(scene, scene.children)\n})\n\nonMounted(() => {\n  camera.zoom = 1;\n  const CircleMesh = createWaveCircle(props.size)\n  CircleMesh.position.z = 0\n  CircleMesh.rotateX(-Math.PI / 4)\n  scene.add( CircleMesh );\n  const axesHelper = new THREE.AxesHelper(5000);\n  // scene.add(axesHelper);\n  const CircleElement = document.getElementById('Circle')\n  if (CircleElement) CircleElement.appendChild(renderer.domElement)\n  const render = () => {\n    renderer.render(scene, camera)\n    camera.updateProjectionMatrix()\n    // controls.update()\n    timer = requestAnimationFrame(render)\n  }\n\n  render()\n})\n\nonBeforeUpdate(() => {\n  console.log('onBeforeUpdate')\n  renderer.clear()\n  scene.remove.apply(scene, scene.children)\n  scene.remove.apply(scene, scene.children)\n  renderer.forceContextLoss()\n  cancelAnimationFrame(timer)\n  const gl = renderer.domElement.getContext('webgl')\n  gl && gl.getExtension('WEBGL_lose_context')?.loseContext()\n})\n</script>"],"names":["vertexShader","fragmentShader","createWaveCircle","__name","size","geometry","THREE.CircleGeometry","material","THREE.ShaderMaterial","THREE.DoubleSide","mesh","THREE.Mesh","clock","THREE.Clock","animate","elapsedTime","timer","onBeforeMount","scene","onMounted","camera","CircleMesh","props","THREE.AxesHelper","CircleElement","renderer","render","onBeforeUpdate","gl","_a"],"mappings":"0PAAA,MAAMA,EAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAxBC,EAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECI1BC,EAAmBC,EAAA,CAACC,EAAe,KAAO,CAC9C,MAAMC,EAAW,IAAIC,EAAqBF,EAAO,GAAI,EAAE,EACjDG,EAAW,IAAIC,EAAqB,CACxC,aAAAR,EACA,eAAAC,EACA,SAAU,CAER,MAAO,CACL,MAAO,CACT,CACF,EACA,KAAMQ,EACN,YAAa,GACb,UAAW,GACX,WAAY,EAAA,CAMb,EACKC,EAAO,IAAIC,EAAWN,EAAUE,CAAQ,EAC9CG,EAAK,KAAO,cAEN,MAAAE,EAAQ,IAAIC,EAClB,SAASC,GAAU,CACX,MAAAC,EAAcH,EAAM,iBACjBL,EAAA,SAAS,MAAM,MAAQQ,EAChC,sBAAsBD,CAAO,CAC/B,CAJS,OAAAX,EAAAW,EAAA,WAMDA,IAEDJ,CACT,EAlCyB,6HCezB,IAAIM,EAAa,KAEjB,OAAAC,EAAc,IAAM,CACdD,GAAO,qBAAqBA,CAAK,EACrCE,EAAM,OAAO,MAAMA,EAAOA,EAAM,QAAQ,CAAA,CACzC,EAEDC,EAAU,IAAM,CACdC,EAAO,KAAO,EACR,MAAAC,EAAanB,EAAiBoB,EAAM,IAAI,EAC9CD,EAAW,SAAS,EAAI,EACxBA,EAAW,QAAQ,CAAC,KAAK,GAAK,CAAC,EAC/BH,EAAM,IAAKG,CAAW,EACH,IAAIE,EAAiB,GAAI,EAEtC,MAAAC,EAAgB,SAAS,eAAe,QAAQ,EAClDA,GAA6BA,EAAA,YAAYC,EAAS,UAAU,EAChE,MAAMC,EAASvB,EAAA,IAAM,CACVsB,EAAA,OAAOP,EAAOE,CAAM,EAC7BA,EAAO,uBAAuB,EAE9BJ,EAAQ,sBAAsBU,CAAM,CAAA,EAJvB,UAORA,GAAA,CACR,EAEDC,EAAe,IAAM,OACnB,QAAQ,IAAI,gBAAgB,EAC5BF,EAAS,MAAM,EACfP,EAAM,OAAO,MAAMA,EAAOA,EAAM,QAAQ,EACxCA,EAAM,OAAO,MAAMA,EAAOA,EAAM,QAAQ,EACxCO,EAAS,iBAAiB,EAC1B,qBAAqBT,CAAK,EAC1B,MAAMY,EAAKH,EAAS,WAAW,WAAW,OAAO,EACjDG,KAAMC,EAAAD,EAAG,aAAa,oBAAoB,IAApC,MAAAC,EAAuC,cAAY,CAC1D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}